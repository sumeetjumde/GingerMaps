{"ast":null,"code":"var __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n  return t;\n};\nimport * as React from \"react\";\nimport { Component } from \"react\";\nimport { createBlueprint } from \"./blueprint\";\nimport getDisplayName from \"./utils/getDisplayName\";\nimport getUniqueKey from \"./utils/getUniqueKey\";\nimport isReferentiallyTransparentFunctionComponent from \"./utils/isReferentiallyTransparentFunctionComponent\";\nvar hasWillReceivePropsCallback = function (e) {\n  return e.kind === \"componentWillReceivePropsCallback\";\n};\nvar AssemblyBase = function (_super) {\n  __extends(AssemblyBase, _super);\n  function AssemblyBase(blueprint, target, isReferentiallyTransparent, props, context) {\n    var _this = _super.call(this, props, context) || this;\n    _this.pendingDataUpdate = false;\n    _this.newestState = {};\n    _this.unmounted = false;\n    _this.newestProps = props;\n    _this.newestContext = context;\n    _this.isReferentiallyTransparent = isReferentiallyTransparent;\n    _this.target = target;\n    _this.callbackList = blueprint.instanceCallbacks();\n    _this.hasWillReceivePropsCallback = _this.callbackList.some(hasWillReceivePropsCallback);\n    _this.computed = _this.runInstanceCallbacks({\n      props: props,\n      context: context,\n      component: _this.target\n    });\n    _this.state = _this.newestState;\n    return _this;\n  }\n  AssemblyBase.prototype.getChildContext = function () {\n    return this.computed.childContext;\n  };\n  AssemblyBase.prototype.componentWillMount = function () {\n    return this.runLifeCycleCallbacks(\"componentWillMountCallback\");\n  };\n  AssemblyBase.prototype.componentDidMount = function () {\n    return this.runLifeCycleCallbacks(\"componentDidMountCallback\");\n  };\n  AssemblyBase.prototype.componentWillUnmount = function () {\n    this.unmounted = true;\n    return this.runLifeCycleCallbacks(\"componentWillUnmountCallback\");\n  };\n  AssemblyBase.prototype.componentWillUpdate = function () {\n    return this.runLifeCycleCallbacks(\"componentWillUpdateCallback\");\n  };\n  AssemblyBase.prototype.componentDidUpdate = function () {\n    return this.runLifeCycleCallbacks(\"componentDidUpdateCallback\");\n  };\n  AssemblyBase.prototype.componentWillReceiveProps = function (nextProps, nextContext) {\n    this.newestProps = nextProps;\n    this.newestContext = nextContext;\n    this.handleDataUpdate({\n      props: nextProps,\n      context: nextContext,\n      component: this.target\n    });\n  };\n  AssemblyBase.prototype.shouldComponentUpdate = function (nextProps, nextState, nextContext) {\n    if (this.state !== nextState && !this.hasWillReceivePropsCallback) {\n      // State based props was not computed before, do it now.\n      this.handleDataUpdate({\n        props: nextProps,\n        context: nextContext,\n        component: this.target\n      });\n    }\n    var callbacks = this.computed.lifeCycleCallbacks.shouldComponentUpdateCallback;\n    if (callbacks) {\n      for (var i = 0; i < callbacks.length; i++) {\n        if (!callbacks[i]()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n  AssemblyBase.prototype.render = function () {\n    var _a = this.computed,\n      Component = _a.component,\n      props = _a.props;\n    if (!Component) {\n      return null;\n    }\n    if (Component === this.target && this.isReferentiallyTransparent || isReferentiallyTransparentFunctionComponent(Component)) {\n      return Component(props);\n    }\n    return React.createElement(Component, __assign({}, props));\n  };\n  AssemblyBase.prototype.runLifeCycleCallbacks = function (name) {\n    var callbacks = this.computed.lifeCycleCallbacks[name];\n    if (callbacks) {\n      callbacks.forEach(function (cb) {\n        return cb();\n      });\n    }\n  };\n  AssemblyBase.prototype.applyStateDiff = function (stateDiff) {\n    this.newestState = __assign({}, this.newestState, stateDiff);\n  };\n  AssemblyBase.prototype.setStateWithLifeCycle = function (stateDiff, callback, init, startAt) {\n    if (init === void 0) {\n      init = this.defaultInit;\n    }\n    if (startAt === void 0) {\n      startAt = 0;\n    }\n    if (this.pendingDataUpdate) {\n      // we are in the middle of a data update.\n      if (!this.pendingDataUpdate.dirty || startAt < this.pendingDataUpdate.startAt) {\n        this.pendingDataUpdate.dirty = true;\n        this.pendingDataUpdate.init = init;\n        this.pendingDataUpdate.startAt = startAt;\n      }\n      if (callback) {\n        this.pendingDataUpdate.callbacks.push(callback);\n      }\n      this.applyStateDiff(stateDiff);\n    } else if (this.hasWillReceivePropsCallback) {\n      // runs callbacks with the new state which will run the `componentWillReceiveProps` lifecycle\n      this.handleDataUpdate(init, startAt, stateDiff, callback);\n    } else {\n      // state changes are batched and props will be recalculated in `shouldComponentUpdate`.\n      this.applyStateDiff(stateDiff);\n      this.setState(this.newestState, callback);\n    }\n  };\n  Object.defineProperty(AssemblyBase.prototype, \"defaultInit\", {\n    get: function () {\n      return {\n        props: this.newestProps,\n        context: this.newestContext,\n        component: this.target\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  AssemblyBase.prototype.handleDataUpdate = function (init, startAt, stateDiff, callback) {\n    if (init === void 0) {\n      init = this.defaultInit;\n    }\n    if (startAt === void 0) {\n      startAt = 0;\n    }\n    if (stateDiff === void 0) {\n      stateDiff = {};\n    }\n    if (callback === void 0) {\n      callback = null;\n    }\n    var oldState = this.newestState;\n    if (stateDiff) {\n      this.applyStateDiff(stateDiff);\n    }\n    this.pendingDataUpdate = {\n      callbacks: callback ? [callback] : []\n    };\n    this.computed = this.runInstanceCallbacks(init, startAt);\n    var callbacks = this.pendingDataUpdate.callbacks;\n    this.pendingDataUpdate = null;\n    if (this.newestState !== oldState) {\n      // Component could be unmounted because something during the lifecycle call can\n      // cause a parent component to unmount this before it completed its data update.\n      if (!this.unmounted) {\n        this.setState(this.newestState, function () {\n          return callbacks.forEach(function (cb) {\n            return cb();\n          });\n        });\n      }\n    }\n  };\n  AssemblyBase.prototype.runInstanceCallbacks = function (init, startAt) {\n    var _this = this;\n    if (startAt === void 0) {\n      startAt = 0;\n    }\n    var interim = __assign({}, init);\n    if (!interim.lifeCycleCallbacks) {\n      interim.lifeCycleCallbacks = {};\n    }\n    var _loop_1 = function (idx) {\n      var entry = this_1.callbackList[idx];\n      switch (entry.kind) {\n        case \"propsCallback\":\n          interim.props = entry.callback(interim.props, this_1.newestState, interim.context);\n          break;\n        case \"stateCallback\":\n          {\n            var sc_1 = entry;\n            if (this_1.hasWillReceivePropsCallback) {\n              sc_1.init = __assign({}, interim);\n              sc_1.startAt = idx;\n            }\n            if (!sc_1.called) {\n              sc_1.called = true;\n              var initState = function (name, value) {\n                var unique = getUniqueKey(name, _this.newestState);\n                _this.applyStateDiff((_a = {}, _a[unique] = value, _a));\n                var updater = function (val, callback) {\n                  _this.setStateWithLifeCycle((_a = {}, _a[unique] = val, _a), callback, sc_1.init, sc_1.startAt);\n                  var _a;\n                };\n                return {\n                  name: unique,\n                  updater: updater\n                };\n                var _a;\n              };\n              entry.callback(initState, interim.props, this_1.newestState, interim.context);\n            }\n          }\n          break;\n        case \"childContextCallback\":\n          interim.childContext = entry.callback(interim.childContext, interim.props, this_1.newestState, interim.context);\n          break;\n        case \"skipCallback\":\n          idx += entry.callback(interim.props, this_1.newestState, interim.context);\n          break;\n        case \"renderCallback\":\n          interim.component = entry.callback(interim.component, interim.props, this_1.newestState, interim.context);\n          break;\n        case \"lazyLoadCallback\":\n          var list = entry.callback(interim.props, this_1.newestState, interim.context);\n          if (list && list.length > 0) {\n            this_1.callbackList = this_1.callbackList.slice(0, idx + 1).concat(list, this_1.callbackList.slice(idx + 1));\n            if (!this_1.hasWillReceivePropsCallback) {\n              this_1.hasWillReceivePropsCallback = list.some(hasWillReceivePropsCallback);\n            }\n          }\n          break;\n        case \"componentWillReceivePropsCallback\":\n          {\n            var cc = entry;\n            var callback = entry.callback(interim.props, this_1.newestState, interim.context);\n            if (cc.called && this_1.pendingDataUpdate) {\n              // Props changed so we need to run this lifecycle.\n              callback();\n              if (this_1.pendingDataUpdate.dirty) {\n                // State changed during lifecycle, so we need to recalculated from an earlier position.\n                this_1.pendingDataUpdate.dirty = false;\n                return {\n                  value: this_1.runInstanceCallbacks(this_1.pendingDataUpdate.init, this_1.pendingDataUpdate.startAt)\n                };\n              }\n            } else {\n              cc.called = true;\n            }\n          }\n          break;\n        case \"componentWillMountCallback\":\n        case \"componentDidMountCallback\":\n        case \"componentWillUnmountCallback\":\n        case \"shouldComponentUpdateCallback\":\n        case \"componentWillUpdateCallback\":\n        case \"componentDidUpdateCallback\":\n          {\n            var hasCallbacks = interim.lifeCycleCallbacks[entry.kind] !== undefined;\n            var callback = entry.callback(interim.props, this_1.newestState, interim.context);\n            interim.lifeCycleCallbacks = __assign({}, interim.lifeCycleCallbacks, (_a = {}, _a[entry.kind] = hasCallbacks ? interim.lifeCycleCallbacks[entry.kind].concat([callback]) : [callback], _a));\n          }\n          break;\n        default:\n          throw new Error(\"Unknown callback entry '\" + entry.kind + \"'\");\n      }\n      out_idx_1 = idx;\n      var _a;\n    };\n    var this_1 = this,\n      out_idx_1;\n    for (var idx = startAt; idx < this.callbackList.length; idx++) {\n      var state_1 = _loop_1(idx);\n      idx = out_idx_1;\n      if (typeof state_1 === \"object\") return state_1.value;\n    }\n    return interim;\n  };\n  return AssemblyBase;\n}(Component);\nexport function assemble() {\n  var callbacks = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    callbacks[_i] = arguments[_i];\n  }\n  var blueprint = createBlueprint.apply(void 0, callbacks);\n  return function (target) {\n    var isReferentiallyTransparent = isReferentiallyTransparentFunctionComponent(target);\n    var targetName = getDisplayName(target);\n    var assembled = (_a = function (_super) {\n      __extends(class_1, _super);\n      function class_1(props, context) {\n        return _super.call(this, blueprint, target, isReferentiallyTransparent, props, context) || this;\n      }\n      return class_1;\n    }(AssemblyBase), _a.displayName = isReferentiallyTransparent ? targetName : \"Assembled(\" + targetName + \")\", _a);\n    blueprint.staticCallbacks.forEach(function (cb) {\n      return cb(assembled, target);\n    });\n    return assembled;\n    var _a;\n  };\n}\nexport default assemble;","map":{"version":3,"names":["React","Component","createBlueprint","getDisplayName","getUniqueKey","isReferentiallyTransparentFunctionComponent","hasWillReceivePropsCallback","e","kind","AssemblyBase","_super","__extends","blueprint","target","isReferentiallyTransparent","props","context","_this","call","pendingDataUpdate","newestState","unmounted","newestProps","newestContext","callbackList","instanceCallbacks","some","computed","runInstanceCallbacks","component","state","prototype","getChildContext","childContext","componentWillMount","runLifeCycleCallbacks","componentDidMount","componentWillUnmount","componentWillUpdate","componentDidUpdate","componentWillReceiveProps","nextProps","nextContext","handleDataUpdate","shouldComponentUpdate","nextState","callbacks","lifeCycleCallbacks","shouldComponentUpdateCallback","i","length","render","_a","createElement","__assign","name","forEach","cb","applyStateDiff","stateDiff","setStateWithLifeCycle","callback","init","startAt","defaultInit","dirty","push","setState","Object","defineProperty","get","oldState","interim","idx","entry","this_1","sc_1","called","initState","value","unique","updater","val","list","slice","concat","cc","hasCallbacks","undefined","Error","out_idx_1","assemble","_i","arguments","apply","targetName","assembled","class_1","displayName","staticCallbacks"],"sources":["/Users/sumeetpravinjumde/Documents/Work/Coding/Ginger/Frontend/node_modules/reassemble/lib/assemble.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { ComponentClass, Component } from \"react\";\n\nimport { ReactComponent, ReactAnyComponent, ComponentEnhancer } from \"./types\";\nimport {\n  createBlueprint, InstanceCallbackListTypesafe, StateUpdater, LifeCycleCallbackTypes,\n  Blueprint, InstanceCallbackEntry, ComponentCallbacks,\n} from \"./blueprint\";\nimport getDisplayName from \"./utils/getDisplayName\";\nimport getUniqueKey from \"./utils/getUniqueKey\";\nimport isReferentiallyTransparentFunctionComponent from \"./utils/isReferentiallyTransparentFunctionComponent\";\n\ntype ComponentData = {\n  props: any,\n  context: any,\n  component: ReactAnyComponent,\n  childContext?: any,\n  lifeCycleCallbacks?: {[P in keyof LifeCycleCallbackTypes]: Function[]} & { [name: string]: Function[] },\n};\n\ntype StateCallbackEntry = InstanceCallbackEntry<\"stateCallback\"> & {\n  init?: ComponentData,\n  called?: boolean,\n  startAt?: number,\n};\n\ntype ComponentWillReceivePropsCallbackkEntry = InstanceCallbackEntry<\"componentWillReceivePropsCallback\"> & {\n  called?: boolean,\n};\n\ntype PendingDataUpdate = {\n  dirty?: boolean,\n  init?: ComponentData,\n  startAt?: number,\n  callbacks?: SetStateCallback[],\n};\n\ntype SetStateCallback = () => void;\n\nconst hasWillReceivePropsCallback = (e: InstanceCallbackEntry<any>) => e.kind === \"componentWillReceivePropsCallback\";\n\nclass AssemblyBase<T> extends Component<T, any> {\n  private target: ReactComponent<any> | string;\n  private isReferentiallyTransparent: boolean;\n  private callbackList: InstanceCallbackListTypesafe;\n  private hasWillReceivePropsCallback: boolean;\n  private computed: ComponentData;\n  private pendingDataUpdate: PendingDataUpdate = false;\n  private newestProps: any;\n  private newestContext: any;\n  private newestState: any = {};\n  private unmounted = false;\n\n  constructor(\n    blueprint: Blueprint,\n    target: ReactComponent<any> | string,\n    isReferentiallyTransparent: boolean,\n    props: any,\n    context: any,\n  ) {\n    super(props, context);\n    this.newestProps = props;\n    this.newestContext = context;\n    this.isReferentiallyTransparent = isReferentiallyTransparent;\n    this.target = target;\n    this.callbackList = blueprint.instanceCallbacks();\n    this.hasWillReceivePropsCallback = this.callbackList.some(hasWillReceivePropsCallback);\n    this.computed = this.runInstanceCallbacks({ props, context, component: this.target });\n    this.state = this.newestState;\n  }\n\n  public getChildContext() { return this.computed.childContext; }\n  public componentWillMount() { return this.runLifeCycleCallbacks(\"componentWillMountCallback\"); }\n  public componentDidMount() { return this.runLifeCycleCallbacks(\"componentDidMountCallback\"); }\n  public componentWillUnmount() {\n    this.unmounted = true;\n    return this.runLifeCycleCallbacks(\"componentWillUnmountCallback\");\n  }\n  public componentWillUpdate() { return this.runLifeCycleCallbacks(\"componentWillUpdateCallback\"); }\n  public componentDidUpdate() { return this.runLifeCycleCallbacks(\"componentDidUpdateCallback\"); }\n  public componentWillReceiveProps(nextProps: any, nextContext: any) {\n    this.newestProps = nextProps;\n    this.newestContext = nextContext;\n    this.handleDataUpdate({\n      props: nextProps,\n      context: nextContext,\n      component: this.target,\n    });\n  }\n\n  public shouldComponentUpdate(nextProps: any, nextState: any, nextContext: any) {\n    if (this.state !== nextState && !this.hasWillReceivePropsCallback) {\n      // State based props was not computed before, do it now.\n      this.handleDataUpdate({\n        props: nextProps,\n        context: nextContext,\n        component: this.target,\n      });\n    }\n    const callbacks = this.computed.lifeCycleCallbacks.shouldComponentUpdateCallback;\n    if (callbacks) {\n      for (let i = 0; i < callbacks.length; i++) {\n        if (!callbacks[i]()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  public render() {\n    const {component: Component, props} = this.computed;\n    if (!Component) {\n      return null;\n    }\n    if (\n      Component === this.target && this.isReferentiallyTransparent ||\n      isReferentiallyTransparentFunctionComponent(Component)\n    ) {\n      return (Component as any)(props);\n    }\n    return <Component {...props} />;\n  }\n\n  private runLifeCycleCallbacks(name: keyof LifeCycleCallbackTypes) {\n    const callbacks = this.computed.lifeCycleCallbacks[name];\n    if (callbacks) { callbacks.forEach((cb) => cb()); }\n  }\n\n  private applyStateDiff(stateDiff: any) {\n    this.newestState = { ...this.newestState, ...stateDiff };\n  }\n\n  private setStateWithLifeCycle(\n    stateDiff: any,\n    callback: SetStateCallback,\n    init: ComponentData = this.defaultInit,\n    startAt: number = 0,\n  ) {\n    if (this.pendingDataUpdate) {\n      // we are in the middle of a data update.\n      if (!this.pendingDataUpdate.dirty || startAt < this.pendingDataUpdate.startAt) {\n        this.pendingDataUpdate.dirty = true;\n        this.pendingDataUpdate.init = init;\n        this.pendingDataUpdate.startAt = startAt;\n      }\n      if (callback) {\n        this.pendingDataUpdate.callbacks.push(callback);\n      }\n      this.applyStateDiff(stateDiff);\n    } else if (this.hasWillReceivePropsCallback) {\n      // runs callbacks with the new state which will run the `componentWillReceiveProps` lifecycle\n      this.handleDataUpdate(init, startAt, stateDiff, callback);\n    } else {\n      // state changes are batched and props will be recalculated in `shouldComponentUpdate`.\n      this.applyStateDiff(stateDiff);\n      this.setState(this.newestState, callback);\n    }\n  }\n\n  private get defaultInit(): ComponentData {\n    return {\n      props: this.newestProps,\n      context: this.newestContext,\n      component: this.target,\n    };\n  }\n\n  private handleDataUpdate(\n    init: ComponentData = this.defaultInit,\n    startAt: number = 0,\n    stateDiff: any = {},\n    callback: SetStateCallback = null,\n  ) {\n    const oldState = this.newestState;\n    if (stateDiff) {\n      this.applyStateDiff(stateDiff);\n    }\n    this.pendingDataUpdate = { callbacks: callback ? [callback] : [] };\n    this.computed = this.runInstanceCallbacks(init, startAt);\n    const callbacks = this.pendingDataUpdate.callbacks;\n    this.pendingDataUpdate = null;\n\n    if (this.newestState !== oldState) {\n      // Component could be unmounted because something during the lifecycle call can\n      // cause a parent component to unmount this before it completed its data update.\n      if (!this.unmounted) {\n        this.setState(this.newestState, () => callbacks.forEach((cb) => cb()));\n      }\n    }\n  }\n\n  private runInstanceCallbacks(init: ComponentData, startAt = 0): ComponentData {\n    const interim = { ...init };\n    if (!interim.lifeCycleCallbacks) { interim.lifeCycleCallbacks = {}; }\n    for (let idx = startAt; idx < this.callbackList.length; idx++) {\n      const entry = this.callbackList[idx];\n      switch (entry.kind) {\n        case \"propsCallback\":\n          interim.props = entry.callback(interim.props, this.newestState, interim.context);\n          break;\n        case \"stateCallback\":\n          {\n            const sc = entry as StateCallbackEntry;\n            if (this.hasWillReceivePropsCallback) {\n              sc.init = { ...interim };\n              sc.startAt = idx;\n            }\n            if (!sc.called) {\n              sc.called = true;\n              const initState = (name: string, value: any) => {\n                let unique = getUniqueKey(name, this.newestState);\n                this.applyStateDiff({ [unique]: value });\n                const updater: StateUpdater<any> = (val, callback) => {\n                  this.setStateWithLifeCycle({ [unique]: val }, callback, sc.init, sc.startAt);\n                };\n                return { name: unique, updater };\n              };\n              entry.callback(initState, interim.props, this.newestState, interim.context);\n            }\n          }\n          break;\n        case \"childContextCallback\":\n          interim.childContext = entry.callback(interim.childContext, interim.props, this.newestState, interim.context);\n          break;\n        case \"skipCallback\":\n          idx += entry.callback(interim.props, this.newestState, interim.context);\n          break;\n        case \"renderCallback\":\n          interim.component = entry.callback(interim.component, interim.props, this.newestState, interim.context);\n          break;\n        case \"lazyLoadCallback\":\n          const list = entry.callback(interim.props, this.newestState, interim.context);\n          if (list && list.length > 0) {\n            this.callbackList = [...this.callbackList.slice(0, idx + 1), ...list, ...this.callbackList.slice(idx + 1)];\n            if (!this.hasWillReceivePropsCallback) {\n              this.hasWillReceivePropsCallback = list.some(hasWillReceivePropsCallback);\n            }\n          }\n          break;\n        case \"componentWillReceivePropsCallback\":\n          {\n            const cc = entry as ComponentWillReceivePropsCallbackkEntry;\n            const callback = entry.callback(interim.props, this.newestState, interim.context);\n            if (cc.called && this.pendingDataUpdate) {\n              // Props changed so we need to run this lifecycle.\n              callback();\n              if (this.pendingDataUpdate.dirty) {\n                // State changed during lifecycle, so we need to recalculated from an earlier position.\n                this.pendingDataUpdate.dirty = false;\n                return this.runInstanceCallbacks(this.pendingDataUpdate.init, this.pendingDataUpdate.startAt);\n              }\n            } else {\n              cc.called = true;\n            }\n          }\n          break;\n        case \"componentWillMountCallback\":\n        case \"componentDidMountCallback\":\n        case \"componentWillUnmountCallback\":\n        case \"shouldComponentUpdateCallback\":\n        case \"componentWillUpdateCallback\":\n        case \"componentDidUpdateCallback\":\n          {\n            const hasCallbacks = interim.lifeCycleCallbacks[entry.kind] !== undefined;\n            const callback = entry.callback(interim.props, this.newestState, interim.context);\n            interim.lifeCycleCallbacks = {\n              ...interim.lifeCycleCallbacks,\n              [entry.kind]: hasCallbacks\n                ? [...interim.lifeCycleCallbacks[entry.kind], callback]\n                : [callback],\n            };\n          }\n          break;\n        default:\n          throw new Error(`Unknown callback entry '${(entry as any).kind}'`);\n      }\n    }\n    return interim;\n  }\n}\n\nexport function assemble(...callbacks: ComponentCallbacks[]): ComponentEnhancer<any, any>;\nexport function assemble<TInner, TOuter>(...callbacks: ComponentCallbacks[]): ComponentEnhancer<TInner, TOuter>;\nexport function assemble<TInner, TOuter>(...callbacks: ComponentCallbacks[]): ComponentEnhancer<TInner, TOuter> {\n  const blueprint = createBlueprint(...callbacks);\n  return (target: ReactComponent<TInner>) => {\n    const isReferentiallyTransparent = isReferentiallyTransparentFunctionComponent(target);\n    const targetName = getDisplayName(target);\n    const assembled: ComponentClass<TOuter> = class extends AssemblyBase<TOuter> {\n      public static displayName = isReferentiallyTransparent\n        ? targetName\n        : `Assembled(${targetName})`;\n\n      constructor(props: any, context: any) {\n        super(blueprint, target, isReferentiallyTransparent, props, context);\n      }\n    };\n    blueprint.staticCallbacks.forEach((cb) => cb(assembled, target));\n    return assembled;\n  };\n}\n\nexport default assemble;\n"],"mappings":";;;;;;;;;;;;;;AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAAyBC,SAAS,QAAQ,OAAO;AAGjD,SACEC,eAAe,QAEV,aAAa;AACpB,OAAOC,cAAc,MAAM,wBAAwB;AACnD,OAAOC,YAAY,MAAM,sBAAsB;AAC/C,OAAOC,2CAA2C,MAAM,qDAAqD;AA6B7G,IAAMC,2BAA2B,GAAG,SAAAA,CAACC,CAA6B;EAAK,OAAAA,CAAC,CAACC,IAAI,KAAK,mCAAmC;AAA9C,CAA8C;AAErH,IAAAC,YAAA,aAAAC,MAAA;EAA8BC,SAAA,CAAAF,YAAA,EAAAC,MAAA;EAY5B,SAAAD,aACEG,SAAoB,EACpBC,MAAoC,EACpCC,0BAAmC,EACnCC,KAAU,EACVC,OAAY;IALd,IAAAC,KAAA,GAOEP,MAAA,CAAAQ,IAAA,OAAMH,KAAK,EAAEC,OAAO,CAAC;IAbfC,KAAA,CAAAE,iBAAiB,GAAsB,KAAK;IAG5CF,KAAA,CAAAG,WAAW,GAAQ,EAAE;IACrBH,KAAA,CAAAI,SAAS,GAAG,KAAK;IAUvBJ,KAAI,CAACK,WAAW,GAAGP,KAAK;IACxBE,KAAI,CAACM,aAAa,GAAGP,OAAO;IAC5BC,KAAI,CAACH,0BAA0B,GAAGA,0BAA0B;IAC5DG,KAAI,CAACJ,MAAM,GAAGA,MAAM;IACpBI,KAAI,CAACO,YAAY,GAAGZ,SAAS,CAACa,iBAAiB,EAAE;IACjDR,KAAI,CAACX,2BAA2B,GAAGW,KAAI,CAACO,YAAY,CAACE,IAAI,CAACpB,2BAA2B,CAAC;IACtFW,KAAI,CAACU,QAAQ,GAAGV,KAAI,CAACW,oBAAoB,CAAC;MAAEb,KAAK,EAAAA,KAAA;MAAEC,OAAO,EAAAA,OAAA;MAAEa,SAAS,EAAEZ,KAAI,CAACJ;IAAM,CAAE,CAAC;IACrFI,KAAI,CAACa,KAAK,GAAGb,KAAI,CAACG,WAAW;;EAC/B;EAEOX,YAAA,CAAAsB,SAAA,CAAAC,eAAe,GAAtB;IAA2B,OAAO,IAAI,CAACL,QAAQ,CAACM,YAAY;EAAE,CAAC;EACxDxB,YAAA,CAAAsB,SAAA,CAAAG,kBAAkB,GAAzB;IAA8B,OAAO,IAAI,CAACC,qBAAqB,CAAC,4BAA4B,CAAC;EAAE,CAAC;EACzF1B,YAAA,CAAAsB,SAAA,CAAAK,iBAAiB,GAAxB;IAA6B,OAAO,IAAI,CAACD,qBAAqB,CAAC,2BAA2B,CAAC;EAAE,CAAC;EACvF1B,YAAA,CAAAsB,SAAA,CAAAM,oBAAoB,GAA3B;IACE,IAAI,CAAChB,SAAS,GAAG,IAAI;IACrB,OAAO,IAAI,CAACc,qBAAqB,CAAC,8BAA8B,CAAC;EACnE,CAAC;EACM1B,YAAA,CAAAsB,SAAA,CAAAO,mBAAmB,GAA1B;IAA+B,OAAO,IAAI,CAACH,qBAAqB,CAAC,6BAA6B,CAAC;EAAE,CAAC;EAC3F1B,YAAA,CAAAsB,SAAA,CAAAQ,kBAAkB,GAAzB;IAA8B,OAAO,IAAI,CAACJ,qBAAqB,CAAC,4BAA4B,CAAC;EAAE,CAAC;EACzF1B,YAAA,CAAAsB,SAAA,CAAAS,yBAAyB,GAAhC,UAAiCC,SAAc,EAAEC,WAAgB;IAC/D,IAAI,CAACpB,WAAW,GAAGmB,SAAS;IAC5B,IAAI,CAAClB,aAAa,GAAGmB,WAAW;IAChC,IAAI,CAACC,gBAAgB,CAAC;MACpB5B,KAAK,EAAE0B,SAAS;MAChBzB,OAAO,EAAE0B,WAAW;MACpBb,SAAS,EAAE,IAAI,CAAChB;KACjB,CAAC;EACJ,CAAC;EAEMJ,YAAA,CAAAsB,SAAA,CAAAa,qBAAqB,GAA5B,UAA6BH,SAAc,EAAEI,SAAc,EAAEH,WAAgB;IAC3E,IAAI,IAAI,CAACZ,KAAK,KAAKe,SAAS,IAAI,CAAC,IAAI,CAACvC,2BAA2B,EAAE;MACjE;MACA,IAAI,CAACqC,gBAAgB,CAAC;QACpB5B,KAAK,EAAE0B,SAAS;QAChBzB,OAAO,EAAE0B,WAAW;QACpBb,SAAS,EAAE,IAAI,CAAChB;OACjB,CAAC;IACJ;IACA,IAAMiC,SAAS,GAAG,IAAI,CAACnB,QAAQ,CAACoB,kBAAkB,CAACC,6BAA6B;IAChF,IAAIF,SAAS,EAAE;MACb,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;QACzC,IAAI,CAACH,SAAS,CAACG,CAAC,CAAC,EAAE,EAAE;UACnB,OAAO,KAAK;QACd;MACF;IACF;IACA,OAAO,IAAI;EACb,CAAC;EAEMxC,YAAA,CAAAsB,SAAA,CAAAoB,MAAM,GAAb;IACQ,IAAAC,EAAA,QAAAzB,QAA6C;MAA5C1B,SAAA,GAAAmD,EAAA,CAAAvB,SAAoB;MAAEd,KAAA,GAAAqC,EAAA,CAAArC,KAAK;IAClC,IAAI,CAACd,SAAS,EAAE;MACd,OAAO,IAAI;IACb;IACA,IACEA,SAAS,KAAK,IAAI,CAACY,MAAM,IAAI,IAAI,CAACC,0BAA0B,IAC5DT,2CAA2C,CAACJ,SAAS,CACvD,EAAE;MACA,OAAQA,SAAiB,CAACc,KAAK,CAAC;IAClC;IACA,OAAOf,KAAA,CAAAqD,aAAA,CAACpD,SAAS,EAAAqD,QAAA,KAAKvC,KAAK,EAAI;EACjC,CAAC;EAEON,YAAA,CAAAsB,SAAA,CAAAI,qBAAqB,GAA7B,UAA8BoB,IAAkC;IAC9D,IAAMT,SAAS,GAAG,IAAI,CAACnB,QAAQ,CAACoB,kBAAkB,CAACQ,IAAI,CAAC;IACxD,IAAIT,SAAS,EAAE;MAAEA,SAAS,CAACU,OAAO,CAAC,UAACC,EAAE;QAAK,OAAAA,EAAE,EAAE;MAAJ,CAAI,CAAC;IAAE;EACpD,CAAC;EAEOhD,YAAA,CAAAsB,SAAA,CAAA2B,cAAc,GAAtB,UAAuBC,SAAc;IACnC,IAAI,CAACvC,WAAW,GAAAkC,QAAA,KAAQ,IAAI,CAAClC,WAAW,EAAKuC,SAAS,CAAE;EAC1D,CAAC;EAEOlD,YAAA,CAAAsB,SAAA,CAAA6B,qBAAqB,GAA7B,UACED,SAAc,EACdE,QAA0B,EAC1BC,IAAsC,EACtCC,OAAmB;IADnB,IAAAD,IAAA;MAAAA,IAAA,GAAsB,IAAI,CAACE,WAAW;IAAA;IACtC,IAAAD,OAAA;MAAAA,OAAA,IAAmB;IAAA;IAEnB,IAAI,IAAI,CAAC5C,iBAAiB,EAAE;MAC1B;MACA,IAAI,CAAC,IAAI,CAACA,iBAAiB,CAAC8C,KAAK,IAAIF,OAAO,GAAG,IAAI,CAAC5C,iBAAiB,CAAC4C,OAAO,EAAE;QAC7E,IAAI,CAAC5C,iBAAiB,CAAC8C,KAAK,GAAG,IAAI;QACnC,IAAI,CAAC9C,iBAAiB,CAAC2C,IAAI,GAAGA,IAAI;QAClC,IAAI,CAAC3C,iBAAiB,CAAC4C,OAAO,GAAGA,OAAO;MAC1C;MACA,IAAIF,QAAQ,EAAE;QACZ,IAAI,CAAC1C,iBAAiB,CAAC2B,SAAS,CAACoB,IAAI,CAACL,QAAQ,CAAC;MACjD;MACA,IAAI,CAACH,cAAc,CAACC,SAAS,CAAC;IAChC,CAAC,MAAM,IAAI,IAAI,CAACrD,2BAA2B,EAAE;MAC3C;MACA,IAAI,CAACqC,gBAAgB,CAACmB,IAAI,EAAEC,OAAO,EAAEJ,SAAS,EAAEE,QAAQ,CAAC;IAC3D,CAAC,MAAM;MACL;MACA,IAAI,CAACH,cAAc,CAACC,SAAS,CAAC;MAC9B,IAAI,CAACQ,QAAQ,CAAC,IAAI,CAAC/C,WAAW,EAAEyC,QAAQ,CAAC;IAC3C;EACF,CAAC;EAEDO,MAAA,CAAAC,cAAA,CAAY5D,YAAA,CAAAsB,SAAA,eAAW;SAAvB,SAAAuC,CAAA;MACE,OAAO;QACLvD,KAAK,EAAE,IAAI,CAACO,WAAW;QACvBN,OAAO,EAAE,IAAI,CAACO,aAAa;QAC3BM,SAAS,EAAE,IAAI,CAAChB;OACjB;IACH,CAAC;;;;EAEOJ,YAAA,CAAAsB,SAAA,CAAAY,gBAAgB,GAAxB,UACEmB,IAAsC,EACtCC,OAAmB,EACnBJ,SAAmB,EACnBE,QAAiC;IAHjC,IAAAC,IAAA;MAAAA,IAAA,GAAsB,IAAI,CAACE,WAAW;IAAA;IACtC,IAAAD,OAAA;MAAAA,OAAA,IAAmB;IAAA;IACnB,IAAAJ,SAAA;MAAAA,SAAA,KAAmB;IAAA;IACnB,IAAAE,QAAA;MAAAA,QAAA,OAAiC;IAAA;IAEjC,IAAMU,QAAQ,GAAG,IAAI,CAACnD,WAAW;IACjC,IAAIuC,SAAS,EAAE;MACb,IAAI,CAACD,cAAc,CAACC,SAAS,CAAC;IAChC;IACA,IAAI,CAACxC,iBAAiB,GAAG;MAAE2B,SAAS,EAAEe,QAAQ,GAAG,CAACA,QAAQ,CAAC,GAAG;IAAE,CAAE;IAClE,IAAI,CAAClC,QAAQ,GAAG,IAAI,CAACC,oBAAoB,CAACkC,IAAI,EAAEC,OAAO,CAAC;IACxD,IAAMjB,SAAS,GAAG,IAAI,CAAC3B,iBAAiB,CAAC2B,SAAS;IAClD,IAAI,CAAC3B,iBAAiB,GAAG,IAAI;IAE7B,IAAI,IAAI,CAACC,WAAW,KAAKmD,QAAQ,EAAE;MACjC;MACA;MACA,IAAI,CAAC,IAAI,CAAClD,SAAS,EAAE;QACnB,IAAI,CAAC8C,QAAQ,CAAC,IAAI,CAAC/C,WAAW,EAAE;UAAM,OAAA0B,SAAS,CAACU,OAAO,CAAC,UAACC,EAAE;YAAK,OAAAA,EAAE,EAAE;UAAJ,CAAI,CAAC;QAA/B,CAA+B,CAAC;MACxE;IACF;EACF,CAAC;EAEOhD,YAAA,CAAAsB,SAAA,CAAAH,oBAAoB,GAA5B,UAA6BkC,IAAmB,EAAEC,OAAW;IAA7D,IAAA9C,KAAA;IAAkD,IAAA8C,OAAA;MAAAA,OAAA,IAAW;IAAA;IAC3D,IAAMS,OAAO,GAAAlB,QAAA,KAAQQ,IAAI,CAAE;IAC3B,IAAI,CAACU,OAAO,CAACzB,kBAAkB,EAAE;MAAEyB,OAAO,CAACzB,kBAAkB,GAAG,EAAE;IAAE;4BAC3D0B,GAAG;MACV,IAAMC,KAAK,GAAGC,MAAA,CAAKnD,YAAY,CAACiD,GAAG,CAAC;MACpC,QAAQC,KAAK,CAAClE,IAAI;QAChB,KAAK,eAAe;UAClBgE,OAAO,CAACzD,KAAK,GAAG2D,KAAK,CAACb,QAAQ,CAACW,OAAO,CAACzD,KAAK,EAAE4D,MAAA,CAAKvD,WAAW,EAAEoD,OAAO,CAACxD,OAAO,CAAC;UAChF;QACF,KAAK,eAAe;UAClB;YACE,IAAM4D,IAAE,GAAGF,KAA2B;YACtC,IAAIC,MAAA,CAAKrE,2BAA2B,EAAE;cACpCsE,IAAE,CAACd,IAAI,GAAAR,QAAA,KAAQkB,OAAO,CAAE;cACxBI,IAAE,CAACb,OAAO,GAAGU,GAAG;YAClB;YACA,IAAI,CAACG,IAAE,CAACC,MAAM,EAAE;cACdD,IAAE,CAACC,MAAM,GAAG,IAAI;cAChB,IAAMC,SAAS,GAAG,SAAAA,CAACvB,IAAY,EAAEwB,KAAU;gBACzC,IAAIC,MAAM,GAAG5E,YAAY,CAACmD,IAAI,EAAEtC,KAAI,CAACG,WAAW,CAAC;gBACjDH,KAAI,CAACyC,cAAc,EAAAN,EAAA,OAAGA,EAAA,CAAC4B,MAAM,IAAGD,KAAK,EAAA3B,EAAA,EAAG;gBACxC,IAAM6B,OAAO,GAAsB,SAAAA,CAACC,GAAG,EAAErB,QAAQ;kBAC/C5C,KAAI,CAAC2C,qBAAqB,EAAAR,EAAA,OAAGA,EAAA,CAAC4B,MAAM,IAAGE,GAAG,EAAA9B,EAAA,GAAIS,QAAQ,EAAEe,IAAE,CAACd,IAAI,EAAEc,IAAE,CAACb,OAAO,CAAC;;gBAC9E,CAAC;gBACD,OAAO;kBAAER,IAAI,EAAEyB,MAAM;kBAAEC,OAAO,EAAAA;gBAAA,CAAE;;cAClC,CAAC;cACDP,KAAK,CAACb,QAAQ,CAACiB,SAAS,EAAEN,OAAO,CAACzD,KAAK,EAAE4D,MAAA,CAAKvD,WAAW,EAAEoD,OAAO,CAACxD,OAAO,CAAC;YAC7E;UACF;UACA;QACF,KAAK,sBAAsB;UACzBwD,OAAO,CAACvC,YAAY,GAAGyC,KAAK,CAACb,QAAQ,CAACW,OAAO,CAACvC,YAAY,EAAEuC,OAAO,CAACzD,KAAK,EAAE4D,MAAA,CAAKvD,WAAW,EAAEoD,OAAO,CAACxD,OAAO,CAAC;UAC7G;QACF,KAAK,cAAc;UACjByD,GAAG,IAAIC,KAAK,CAACb,QAAQ,CAACW,OAAO,CAACzD,KAAK,EAAE4D,MAAA,CAAKvD,WAAW,EAAEoD,OAAO,CAACxD,OAAO,CAAC;UACvE;QACF,KAAK,gBAAgB;UACnBwD,OAAO,CAAC3C,SAAS,GAAG6C,KAAK,CAACb,QAAQ,CAACW,OAAO,CAAC3C,SAAS,EAAE2C,OAAO,CAACzD,KAAK,EAAE4D,MAAA,CAAKvD,WAAW,EAAEoD,OAAO,CAACxD,OAAO,CAAC;UACvG;QACF,KAAK,kBAAkB;UACrB,IAAMmE,IAAI,GAAGT,KAAK,CAACb,QAAQ,CAACW,OAAO,CAACzD,KAAK,EAAE4D,MAAA,CAAKvD,WAAW,EAAEoD,OAAO,CAACxD,OAAO,CAAC;UAC7E,IAAImE,IAAI,IAAIA,IAAI,CAACjC,MAAM,GAAG,CAAC,EAAE;YAC3ByB,MAAA,CAAKnD,YAAY,GAAOmD,MAAA,CAAKnD,YAAY,CAAC4D,KAAK,CAAC,CAAC,EAAEX,GAAG,GAAG,CAAC,CAAC,CAAAY,MAAA,CAAKF,IAAI,EAAKR,MAAA,CAAKnD,YAAY,CAAC4D,KAAK,CAACX,GAAG,GAAG,CAAC,CAAC,CAAC;YAC1G,IAAI,CAACE,MAAA,CAAKrE,2BAA2B,EAAE;cACrCqE,MAAA,CAAKrE,2BAA2B,GAAG6E,IAAI,CAACzD,IAAI,CAACpB,2BAA2B,CAAC;YAC3E;UACF;UACA;QACF,KAAK,mCAAmC;UACtC;YACE,IAAMgF,EAAE,GAAGZ,KAAgD;YAC3D,IAAMb,QAAQ,GAAGa,KAAK,CAACb,QAAQ,CAACW,OAAO,CAACzD,KAAK,EAAE4D,MAAA,CAAKvD,WAAW,EAAEoD,OAAO,CAACxD,OAAO,CAAC;YACjF,IAAIsE,EAAE,CAACT,MAAM,IAAIF,MAAA,CAAKxD,iBAAiB,EAAE;cACvC;cACA0C,QAAQ,EAAE;cACV,IAAIc,MAAA,CAAKxD,iBAAiB,CAAC8C,KAAK,EAAE;gBAChC;gBACAU,MAAA,CAAKxD,iBAAiB,CAAC8C,KAAK,GAAG,KAAK;;yBAC7BU,MAAA,CAAK/C,oBAAoB,CAAC+C,MAAA,CAAKxD,iBAAiB,CAAC2C,IAAI,EAAEa,MAAA,CAAKxD,iBAAiB,CAAC4C,OAAO;gBAAC;cAC/F;YACF,CAAC,MAAM;cACLuB,EAAE,CAACT,MAAM,GAAG,IAAI;YAClB;UACF;UACA;QACF,KAAK,4BAA4B;QACjC,KAAK,2BAA2B;QAChC,KAAK,8BAA8B;QACnC,KAAK,+BAA+B;QACpC,KAAK,6BAA6B;QAClC,KAAK,4BAA4B;UAC/B;YACE,IAAMU,YAAY,GAAGf,OAAO,CAACzB,kBAAkB,CAAC2B,KAAK,CAAClE,IAAI,CAAC,KAAKgF,SAAS;YACzE,IAAM3B,QAAQ,GAAGa,KAAK,CAACb,QAAQ,CAACW,OAAO,CAACzD,KAAK,EAAE4D,MAAA,CAAKvD,WAAW,EAAEoD,OAAO,CAACxD,OAAO,CAAC;YACjFwD,OAAO,CAACzB,kBAAkB,GAAAO,QAAA,KACrBkB,OAAO,CAACzB,kBAAkB,GAAAK,EAAA,OAAAA,EAAA,CAC5BsB,KAAK,CAAClE,IAAI,IAAG+E,YAAY,GAClBf,OAAO,CAACzB,kBAAkB,CAAC2B,KAAK,CAAClE,IAAI,CAAC,CAAA6E,MAAA,EAAExB,QAAQ,KACpD,CAACA,QAAQ,CAAC,EAAAT,EAAA,EACf;UACH;UACA;QACF;UACE,MAAM,IAAIqC,KAAK,CAAC,6BAA4Bf,KAAa,CAAClE,IAAI,MAAG,CAAC;MACtE;kBAjFOiE,GAAG;;;;;IAAZ,KAAK,IAAIA,GAAG,GAAGV,OAAO,EAAEU,GAAG,GAAG,IAAI,CAACjD,YAAY,CAAC0B,MAAM,EAAEuB,GAAG,EAAE;4BAApDA,GAAG;MAAHA,GAAG,GAAAiB,SAAA;;;IAmFZ,OAAOlB,OAAO;EAChB,CAAC;EACH,OAAA/D,YAAC;AAAD,CA/OA,CAA8BR,SAAS;AAmPvC,OAAM,SAAA0F,SAAA;EAAmC,IAAA7C,SAAA;OAAA,IAAA8C,EAAA,IAAkC,EAAlCA,EAAA,GAAAC,SAAA,CAAA3C,MAAkC,EAAlC0C,EAAA,EAAkC;IAAlC9C,SAAA,CAAA8C,EAAA,IAAAC,SAAA,CAAAD,EAAA;;EACvC,IAAMhF,SAAS,GAAGV,eAAe,CAAA4F,KAAA,SAAIhD,SAAS,CAAC;EAC/C,OAAO,UAACjC,MAA8B;IACpC,IAAMC,0BAA0B,GAAGT,2CAA2C,CAACQ,MAAM,CAAC;IACtF,IAAMkF,UAAU,GAAG5F,cAAc,CAACU,MAAM,CAAC;IACzC,IAAMmF,SAAS,IAAA5C,EAAA,aAAA1C,MAAA;MAAyCC,SAAA,CAAAsF,OAAA,EAAAvF,MAAA;MAKtD,SAAAuF,QAAYlF,KAAU,EAAEC,OAAY;eAClCN,MAAA,CAAAQ,IAAA,OAAMN,SAAS,EAAEC,MAAM,EAAEC,0BAA0B,EAAEC,KAAK,EAAEC,OAAO,CAAC;MACtE;MACF,OAAAiF,OAAC;IAAD,CAR0C,CAAcxF,YAAY,GACpD2C,EAAA,CAAA8C,WAAW,GAAGpF,0BAA0B,GAClDiF,UAAU,GACV,eAAaA,UAAU,MAAI,E,GAKhC;IACDnF,SAAS,CAACuF,eAAe,CAAC3C,OAAO,CAAC,UAACC,EAAE;MAAK,OAAAA,EAAE,CAACuC,SAAS,EAAEnF,MAAM,CAAC;IAArB,CAAqB,CAAC;IAChE,OAAOmF,SAAS;;EAClB,CAAC;AACH;AAEA,eAAeL,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}