{"ast":null,"code":"var __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n  return t;\n};\nimport { propsCallback } from \"./blueprint\";\nimport pick from \"./utils/pick\";\nimport shallowEqual from \"./utils/shallowEqual\";\nexport function withPropsOnChange(shouldMapOrKeys, propsMapper) {\n  var shouldMap = typeof shouldMapOrKeys === \"function\" ? shouldMapOrKeys : function (props, nextProps) {\n    return !shallowEqual(pick.apply(void 0, [props].concat(shouldMapOrKeys)), pick.apply(void 0, [nextProps].concat(shouldMapOrKeys)));\n  };\n  return {\n    instanceCallbacks: function () {\n      var previousProps;\n      var computedProps;\n      return [propsCallback(function (props) {\n        if (previousProps === undefined || shouldMap(previousProps, props)) {\n          computedProps = propsMapper(props);\n        }\n        previousProps = props;\n        return __assign({}, props, computedProps);\n      })];\n    }\n  };\n}\nexport default withPropsOnChange;","map":{"version":3,"names":["propsCallback","pick","shallowEqual","withPropsOnChange","shouldMapOrKeys","propsMapper","shouldMap","props","nextProps","apply","concat","instanceCallbacks","previousProps","computedProps","undefined","__assign"],"sources":["/Users/sumeetpravinjumde/Documents/Work/Coding/Ginger/Frontend/node_modules/reassemble/lib/withPropsOnChange.ts"],"sourcesContent":["import { Composable, propsCallback } from \"./blueprint\";\nimport { PredicateDiff, Mapper } from \"./types\";\nimport pick from \"./utils/pick\";\nimport shallowEqual from \"./utils/shallowEqual\";\n\nexport function withPropsOnChange(\n  shouldMapOrKeys: string[] | PredicateDiff<any>,\n  propsMapper: Mapper<any, any>,\n): Composable;\n\nexport function withPropsOnChange<TPropsIn, TPropsOut>(\n  shouldMapOrKeys: Array<keyof TPropsIn> | PredicateDiff<TPropsIn>,\n  propsMapper: Mapper<TPropsIn, TPropsOut>,\n): Composable;\n\nexport function withPropsOnChange<TPropsIn, TPropsOut>(\n  shouldMapOrKeys: Array<keyof TPropsIn> | PredicateDiff<TPropsIn>,\n  propsMapper: Mapper<TPropsIn, TPropsOut>,\n): Composable {\n  const shouldMap = typeof shouldMapOrKeys === \"function\"\n    ? shouldMapOrKeys\n    : (props: TPropsIn, nextProps: TPropsIn) => !shallowEqual(\n      pick(props, ...shouldMapOrKeys),\n      pick(nextProps, ...shouldMapOrKeys),\n    );\n  return {\n    instanceCallbacks: () => {\n      let previousProps: any;\n      let computedProps: any;\n      return [\n        propsCallback((props) => {\n          if (previousProps === undefined || shouldMap(previousProps, props)) {\n            computedProps = propsMapper(props);\n          }\n          previousProps = props;\n          return { ...props, ...computedProps };\n        }),\n      ];\n    },\n  };\n}\n\nexport default withPropsOnChange;\n"],"mappings":";;;;;;;AAAA,SAAqBA,aAAa,QAAQ,aAAa;AAEvD,OAAOC,IAAI,MAAM,cAAc;AAC/B,OAAOC,YAAY,MAAM,sBAAsB;AAY/C,OAAM,SAAAC,kBACJC,eAAgE,EAChEC,WAAwC;EAExC,IAAMC,SAAS,GAAG,OAAOF,eAAe,KAAK,UAAU,GACnDA,eAAe,GACf,UAACG,KAAe,EAAEC,SAAmB;IAAK,QAACN,YAAY,CACvDD,IAAI,CAAAQ,KAAA,UAACF,KAAK,EAAAG,MAAA,CAAKN,eAAe,IAC9BH,IAAI,CAAAQ,KAAA,UAACD,SAAS,EAAAE,MAAA,CAAKN,eAAe,GACnC;EAH2C,CAG3C;EACH,OAAO;IACLO,iBAAiB,EAAE,SAAAA,CAAA;MACjB,IAAIC,aAAkB;MACtB,IAAIC,aAAkB;MACtB,OAAO,CACLb,aAAa,CAAC,UAACO,KAAK;QAClB,IAAIK,aAAa,KAAKE,SAAS,IAAIR,SAAS,CAACM,aAAa,EAAEL,KAAK,CAAC,EAAE;UAClEM,aAAa,GAAGR,WAAW,CAACE,KAAK,CAAC;QACpC;QACAK,aAAa,GAAGL,KAAK;QACrB,OAAMQ,QAAA,KAAMR,KAAK,EAAKM,aAAa;MACrC,CAAC,CAAC,CACH;IACH;GACD;AACH;AAEA,eAAeV,iBAAiB"},"metadata":{},"sourceType":"module","externalDependencies":[]}